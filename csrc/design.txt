The MFM decoder is based around a number of data structures, each organized
into levels. The lower the level, the closer it is to the raw flux data
pulled from the FluxEngine file.

These data structures will be organized into a timeline that contains the
entire floppy data recording, made up of slices corresponding to parts that
should be or have been decoded. The point of using a timeline is to isolate
hard-to-decode parts while skipping parts that have already been decoded.

The data structures are:
	Level zero:
		Flux record: a vector of time intervals between detected
		fluxes, on some arbitrary time scale, or a class containing
		this vector. This is just the FluxEngine data after
		decompression.

	Level one:
		MFM pulse train: this is a vector of bits produced by decoding
		the flux deltas, with 1 corresponding to a flux reversal and 0
		to no reversal. It's ready to be parsed by an MFM decoder.

		The mapping between multiples of clock and the number of
		zeroes in an MFM pulse train is nonlinear, so if there are any
		out of spec delays in the flux delta vector, these may become
		arbitrarily long after decoding. (I'll find some principled way
		to deal with these later.)

	Level two:
		Sector data: A class containing subclasses for the three types
		of IBM MFM data chunks: IDAM, IAM, and DAM. (Not implemented
		yet.) Also does the MFM pulse train decoding itself; I might
		split this later.

		Raw bytes: The "serialized" data corresponding to some address
		mark. To be distinguished from just "data", which, particularly
		in the context of DAM and DDAM, refer to the data portion of
		the address mark (i.e. the actual data stored on the floppy,
		not metadata).

The timeline may also contain interfaces that provide a linear view, but I'll
determine that later.
